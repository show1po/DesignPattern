
簡單工廠:不需要實體化
靜態工廠:透過繼承可以改變建立物件的行為
工廠方法:將實體化行為交由次類別實作
抽象工廠:透過介面建立相關家族物件

1.觀察者模式:
物件之間一對多的依賴關係，當一個對象改變時，他所有依賴者會收到通知並自動更新。
PS.1對1關係應該叫做回調。
Subject -> Observer
2.工廠模式:
(1)簡單工廠/靜態工廠
(2)工廠方法:
(3)抽象工廠:
3.單例模式:
整個應用中只有一個實例。
饿汉式/懒汉式[双重校验锁 推荐用]/内部类[推荐用]/枚举[推荐用]
4.策略模式:
封裝變化、多用組合，少用繼承、針對介面編寫，而非針對實作。
5.轉接器模式:把一個介面轉換成另一個介面。
6.命令模式:將請求封裝成物件，將請求者和動作執行者解耦。
7.裝飾者模式:動態地將責任附加到物件。
PS.開放封閉原則
8.外觀模式:將一群子系統，統一成單一介面。一堆實作，封裝成一個方法。
9.模板方法模式:將演算法步驟，延遲到子類別中，使得子類在不改變結構下，可重新定義步驟。
由三種角色組成:具體方法/抽象方法/鉤子方法。
10.狀態模式:物件內部狀態改變時，行為會跟隨狀態改變而改變，彷彿重新初始化一個類。


參考:https://github.com/mirsfang/ExamplesOfDesignPatterns
一、六大原則:
單一職責原則(Single Responsibility Principle):只有一個原因引起類的變更。
李氏替換原則(Liskov Substitution Principle):父類使用的地方，則子類一定可以替換。
依賴倒轉(Dependence Inversion Principle):針對介面編程，依賴抽象而非具體。
介面隔離原則(Interface Segregation Principle):細分介面，將低耦合。
迪米特法則(Demeter Principle):實體應當減少與其他類發生相互作用
開閉原則(Open Close Principle):對擴展開放，對修改關閉。
合成復用原則(Composite Reuse Principle):多用合成/聚合取代繼承。

一、生成模式 Creational Patterns(5)
Factory Method:用於創建物件的介面，初始化延遲至子類。
Abstract Factory:建立一組相關/相依物件提供一個介面，無須指定具體類。
Builder:將物件建構與他的表示分離。
Prototype:
Singleton:確保一個類只有一個實例，且自行實例化，並向整個系統提供此實例。
二、結構模式 Structural Patterns(7)
Adapter:將兩個不同介面的類別，透過此介面而統一。
Bridge:將抽象和實現解偶。
Composite:將物件組合成樹狀結構，以部分整體的層次結構，維持一致性。
Decorator:動態給物件增加額外責任，比生成子類靈活。
Facade:提供一個高層次介面使子系統更易用。
Flyweight:
Proxy:物件提供控制其他物件的訪問。
三、行為模式 Behavioral Patterns(11)
Chain of Responsibility:鏈起多個物件，則所有物件都有機會處理請求，從而降低請求者和接受者耦合關係。
Command:將請求封裝成物件，undo。
Interpreter:
Iterator:提供方法訪問容器物件中各個元素，且不須暴露該物件內部細節。
Mediator:中介物件封裝一系列物件交互行為，中介者不須顯示相互作用，從而使其耦合鬆散。
Memento:不破壞封裝性前提，保存指定物件內部狀態，供日後恢復原先狀態。	
Observer:物件間一對多的依賴關係，使得物件改變狀態時，其他物件會被通知並自動更新。	
State:物件內在狀態改變時允許其改變行為。
Strategy:定義一組算法，將每個算法封裝，可互相轉換。
Template Method:定義操作中的算法框架，將一些步驟延遲至子類，使其特定步驟可經重定義。
Visitor:封裝資料結構中各元素的操作，在不改變資料結構前提下定義作用於這些元素新的操作。 